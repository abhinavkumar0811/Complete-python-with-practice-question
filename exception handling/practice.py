# Basic (1–30):

# Write a try-except block to catch division by zero.

# Handle invalid integer input using try-except.

# Handle invalid float input using try-except.

# Handle index error in a list.

# Handle key error in a dictionary.

# Handle file not found error while reading a file.

# Handle file not found error while opening a file for writing.

# Handle type error in adding integer and string.

# Handle value error when converting string to int.

# Handle value error when converting string to float.

# Handle attribute error for non-existent attribute.

# Handle zero division in a function.

# Use else block in try-except.

# Use finally block in try-except.

# Handle multiple exceptions in a single block.

# Handle multiple exceptions using separate except blocks.

# Catch exception and print its message.

# Raise an exception manually using raise.

# Raise ValueError manually.

# Raise TypeError manually.

# Raise IndexError manually.

# Use try-except to validate user input for positive number.

# Handle exception when reading from an empty file.

# Handle exception while writing to a read-only file.

# Use try-finally to ensure file is closed.

# Handle custom exception in a class.

# Create a custom exception class NegativeNumberError.

# Handle exception when accessing non-existent list element.

# Handle exception when accessing non-existent dictionary key.

# Handle exception when dividing list elements by user input.

# Intermediate (31–70):
# 31. Handle exception when converting list of strings to integers.
# 32. Handle exception when calculating sqrt of negative number.
# 33. Handle exception in nested try-except.
# 34. Handle exception when popping from empty list.
# 35. Handle exception when removing non-existent element from list.
# 36. Handle exception when opening non-existent file in with block.
# 37. Use else in try-except-else-finally.
# 38. Handle exception when concatenating list and integer.
# 39. Handle exception when slicing beyond list length.
# 40. Handle exception when accessing tuple element out of range.
# 41. Handle exception when unpacking wrong number of values.
# 42. Handle exception when converting empty string to int.
# 43. Handle exception when dividing by variable input.
# 44. Handle exception when using unsupported operand types.
# 45. Handle exception in recursive function.
# 46. Handle exception when reading a CSV file with missing values.
# 47. Handle exception when parsing JSON with invalid format.
# 48. Raise exception if number is negative.
# 49. Raise exception if string is empty.
# 50. Use try-except to catch all exceptions.
# 51. Catch multiple exceptions and differentiate actions.
# 52. Create function to divide two numbers with exception handling.
# 53. Create function to access dictionary key safely.
# 54. Handle exception when using int() on float string.
# 55. Handle exception when importing non-existent module.
# 56. Handle exception when calling undefined function.
# 57. Handle exception when opening file in read mode but file is missing.
# 58. Handle exception when adding element to frozen set.
# 59. Handle exception when converting invalid hexadecimal string.
# 60. Handle exception when accessing negative index beyond list length.
# 61. Handle exception when iterating non-iterable object.
# 62. Handle exception when using max() on empty list.
# 63. Handle exception when using min() on empty list.
# 64. Handle exception when dividing numpy array by zero.
# 65. Handle exception when passing wrong type to function.
# 66. Handle exception when slicing string with invalid indices.
# 67. Handle exception when concatenating string with None.
# 68. Handle exception when accessing attribute of None.
# 69. Raise ZeroDivisionError manually in function.
# 70. Raise KeyError manually in function.

# Advanced (71–100):
# 71. Create custom exception InvalidAgeError and handle it.
# 72. Create custom exception InsufficientBalanceError.
# 73. Create custom exception NegativeInputError.
# 74. Handle exception in nested dictionary access.
# 75. Handle exception in nested list access.
# 76. Handle exception when calling method on wrong object type.
# 77. Use exception handling in file copy operation.
# 78. Use exception handling in file read & write.
# 79. Handle exception in matrix operations.
# 80. Handle exception in 2D list access.
# 81. Handle exception in list of dictionaries access.
# 82. Handle exception when converting complex number to int.
# 83. Handle exception in division of float by string.
# 84. Handle exception when using unsupported comparison.
# 85. Handle exception in arithmetic operation with None.
# 86. Handle exception when using eval() on invalid expression.
# 87. Handle exception when parsing invalid date string.
# 88. Handle exception when opening non-existent image file.
# 89. Handle exception in recursive function for factorial of negative number.
# 90. Handle exception when calculating log of zero or negative.
# 91. Handle exception in matrix multiplication with incompatible sizes.
# 92. Use try-except in class method to validate input.
# 93. Use try-except in setter method for validation.
# 94. Use try-except-finally in network request.
# 95. Handle exception when closing already closed file.
# 96. Handle exception when performing operation on empty deque.
# 97. Handle exception in list comprehension with division.
# 98. Handle exception when converting invalid binary string.
# 99. Handle exception when reading JSON with missing key.
# 100. Combine multiple exception types and handle separately in program.